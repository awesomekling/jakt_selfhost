extern struct StringBuilder {
    function append(mutable this, anonymous s: u8)
    function to_string(mutable this) -> String
    function StringBuilder() -> StringBuilder
}

// FIXME: These should not need explicit "-> bool" return types.
function is_ascii_alpha(anonymous c: u8) -> bool => (c >= b'a' and c <= b'z') or (c >= b'A' and c <= b'Z')
function is_ascii_digit(anonymous c: u8) -> bool => (c >= b'0' and c <= b'9')
function is_ascii_hexdigit(anonymous c: u8) -> bool => (c >= b'0' and c <= b'9') or (c >= b'a' and c <= b'f') or (c >= b'A' and c <= b'F')
function is_ascii_alphanumeric(anonymous c: u8) -> bool => is_ascii_alpha(c) or is_ascii_digit(c)

//FIXME: Would be nice to name this Span and not have conflict
struct JaktSpan {
    start: usize
    end: usize
}

enum Token {
    SingleQuotedString(quote: String, span: JaktSpan)
    SingleQuotedByteString(quote: String, span: JaktSpan)
    QuotedString(quote: String, span: JaktSpan)
    Number(number: i64, span: JaktSpan)
    Name(name: String, span: JaktSpan)
    Semicolon(JaktSpan)
    Colon(JaktSpan)
    ColonColon(JaktSpan)
    LParen(JaktSpan)
    RParen(JaktSpan)
    LCurly(JaktSpan)
    RCurly(JaktSpan)
    LSquare(JaktSpan)
    RSquare(JaktSpan)
    PercentSign(JaktSpan)
    Plus(JaktSpan)
    Minus(JaktSpan)
    Equal(JaktSpan)
    PlusEqual(JaktSpan)
    PlusPlus(JaktSpan)
    MinusEqual(JaktSpan)
    MinusMinus(JaktSpan)
    AsteriskEqual(JaktSpan)
    ForwardSlashEqual(JaktSpan)
    PercentSignEqual(JaktSpan)
    NotEqual(JaktSpan)
    DoubleEqual(JaktSpan)
    GreaterThan(JaktSpan)
    GreaterThanOrEqual(JaktSpan)
    LessThan(JaktSpan)
    LessThanOrEqual(JaktSpan)
    LeftArithmeticShift(JaktSpan)
    LeftShift(JaktSpan)
    LeftShiftEqual(JaktSpan)
    RightShift(JaktSpan)
    RightArithmeticShift(JaktSpan)
    RightShiftEqual(JaktSpan)
    Asterisk(JaktSpan)
    Ampersand(JaktSpan)
    AmpersandEqual(JaktSpan)
    Pipe(JaktSpan)
    PipeEqual(JaktSpan)
    Caret(JaktSpan)
    CaretEqual(JaktSpan)
    Dollar(JaktSpan)
    Tilde(JaktSpan)
    ForwardSlash(JaktSpan)
    ExclamationPoint(JaktSpan)
    QuestionMark(JaktSpan)
    QuestionMarkQuestionMark(JaktSpan)
    Comma(JaktSpan)
    Dot(JaktSpan)
    DotDot(JaktSpan)
    Eol(JaktSpan)
    Eof(JaktSpan)
    FatArrow(JaktSpan)
    Garbage(JaktSpan)
}

enum JaktError {
    Message(msg: String, span: JaktSpan)
    MessageWithHint(msg: String, span: JaktSpan, hint: String, hint_span: JaktSpan)
}

struct Lexer {
    index: usize
    input: [u8]
    errors: [JaktError]

    function peek(this) -> u8 {
        if .index >= .input.size() {
            return 0
        }
        return .input[.index]
    }

    function lex_number_or_name(mutable this) throws -> Token {
        let start = .index

        if .index >= .input.size() {
            .errors.push(JaktError::Message(msg: "unexpected eof", span: JaktSpan(start, end: start)))
            return Token::Garbage(JaktSpan(start, end: start))
        }
        if is_ascii_digit(.input[.index]) {
            let mutable total = 0i64

            while .index < .input.size() and is_ascii_digit(.input[.index]) {
                let value = .input[.index]
                ++.index
                let digit: i64 = as_saturated(value - b'0')
                total = total * 10 + digit
            }
            let end = .index
            return Token::Number(number: total, span: JaktSpan(start, end))
        } else if is_ascii_alpha(.input[.index]) or .input[.index] == b'_' {
            let mutable string_builder = StringBuilder()

            while .index < .input.size() and (is_ascii_alphanumeric(.input[.index]) or .input[.index] == b'_') {
                let value = .input[.index]
                ++.index
                string_builder.append(value)
            }
            let end = .index
            return Token::Name(name: string_builder.to_string(), span: JaktSpan(start, end))
        }

        let unknown_char = .input[.index]
        let end = ++.index
        .errors.push(JaktError::Message(msg: format("unknown character: {:c}", unknown_char), span: JaktSpan(start, end)))
        return Token::Garbage(JaktSpan(start, end))
    }

    function lex_quoted_string(mutable this, delimiter: u8) throws -> Token {
        let start = .index

        ++.index

        if .index >= .input.size() {
            .errors.push(JaktError::Message(msg: "unexpected eof", span: JaktSpan(start, end: start)))
            return Token::Garbage(JaktSpan(start, end: start))
        }

        let mutable string_builder = StringBuilder()
        
        let mutable escaped = false
        while .index < .input.size() and .input[.index] != delimiter and escaped == false {
            if .input[.index] == b'\\' {
                escaped = true
            } else {
                escaped = false
            }
            ++.index
        }

        let end = .index
        
        if delimiter == b'\'' {
            //FIXME: JaktError? can not be assigned 'None'
            return Token::SingleQuotedString(quote: string_builder.to_string(), span: JaktSpan(start, end))
        }

        return Token::QuotedString(quote: string_builder.to_string(), span: JaktSpan(start, end))
    }

    function lex_plus(mutable this) -> Token {
        let start = .index
        ++.index
        return match this.peek() {
            (b'=') => Token::PlusEqual(JaktSpan(start, end: ++.index))
            (b'+') => Token::PlusPlus(JaktSpan(start, end: ++.index))
            else => Token::Plus(JaktSpan(start: .index - 1, end: .index))
        }
    }

    function lex_minus(mutable this) -> Token {
        let start = .index
        ++.index
        return match this.peek() {
            (b'=') => Token::MinusEqual(JaktSpan(start, end: ++.index))
            (b'-') => Token::MinusMinus(JaktSpan(start, end: ++.index))
            else => Token::Minus(JaktSpan(start: .index - 1, end: .index))
        }
    }

    function lex_asterisk(mutable this) -> Token {
        let start = .index
        ++.index
        return match this.peek() {
            (b'=') => Token::AsteriskEqual(JaktSpan(start, end: ++.index))
            else => Token::Asterisk(JaktSpan(start: .index - 1, end: .index))
        }
    }

    function lex_forward_slash(mutable this) -> Token {
        let start = .index
        ++.index
        return match this.peek() {
            (b'=') => Token::ForwardSlashEqual(JaktSpan(start, end: ++.index))
            else => Token::ForwardSlash(JaktSpan(start: .index - 1, end: .index))
        }
    }

    function lex_caret(mutable this) -> Token {
        let start = .index
        ++.index
        return match this.peek() {
            (b'=') => Token::CaretEqual(JaktSpan(start, end: ++.index))
            else => Token::Caret(JaktSpan(start: .index - 1, end: .index))
        }
    }

    function lex_pipe(mutable this) -> Token {
        let start = .index
        ++.index
        return match this.peek() {
            (b'=') => Token::PipeEqual(JaktSpan(start, end: ++.index))
            else => Token::Pipe(JaktSpan(start: .index - 1, end: .index))
        }
    }

    function lex_percent_sign(mutable this) -> Token {
        let start = .index
        ++.index
        return match this.peek() {
            (b'=') => Token::PercentSignEqual(JaktSpan(start, end: ++.index))
            else => Token::PercentSign(JaktSpan(start: .index - 1, end: .index))
        }
    }

    function lex_exclamation_point(mutable this) -> Token {
        let start = .index
        ++.index
        return match this.peek() {
            (b'=') => Token::NotEqual(JaktSpan(start, end: ++.index))
            else => Token::ExclamationPoint(JaktSpan(start: .index - 1, end: .index))
        }
    }

    function lex_ampersand(mutable this) -> Token {
        let start = .index
        ++.index
        return match this.peek() {
            (b'=') => Token::AmpersandEqual(JaktSpan(start, end: ++.index))
            else => Token::Ampersand(JaktSpan(start: .index - 1, end: .index))
        }
    }

    function lex_less_than(mutable this) -> Token {
        let start = .index
        ++.index
        return match this.peek() {
            (b'=') => Token::LessThanOrEqual(JaktSpan(start, end: ++.index))
            (b'<') => Token::LeftShift(JaktSpan(start, end: ++.index))
            else => Token::LessThan(JaktSpan(start: .index - 1, end: .index))
        }
    }

    function lex_greater_than(mutable this) -> Token {
        let start = .index
        ++.index
        return match this.peek() {
            (b'=') => Token::GreaterThanOrEqual(JaktSpan(start, end: ++.index))
            (b'>') => Token::RightShift(JaktSpan(start, end: ++.index))
            else => Token::GreaterThan(JaktSpan(start: .index - 1, end: .index))
        }
    }

    function lex_dot(mutable this) -> Token {
        let start = .index
        ++.index
        return match this.peek() {
            (b'.') => Token::DotDot(JaktSpan(start, end: ++.index))
            else => Token::Dot(JaktSpan(start: .index - 1, end: .index))
        }
    }

    function lex_colon(mutable this) -> Token {
        let start = .index
        ++.index
        return match this.peek() {
            (b':') => Token::ColonColon(JaktSpan(start, end: ++.index))
            else => Token::Colon(JaktSpan(start: .index - 1, end: .index))
        }
    }

    function lex_question_mark(mutable this) -> Token {
        let start = .index
        ++.index
        return match this.peek() {
            (b'?') => Token::QuestionMarkQuestionMark(JaktSpan(start, end: ++.index))
            else => Token::QuestionMark(JaktSpan(start: .index - 1, end: .index))
        }
    }

    function lex_equals(mutable this) -> Token {
        let start = .index
        ++.index
        return match this.peek() {
            (b'=') => Token::DoubleEqual(JaktSpan(start, end: ++.index))
            (b'>') => Token::FatArrow(JaktSpan(start, end: ++.index))
            else => Token::Equal(JaktSpan(start: .index - 1, end: .index))
        }
    }

    function next(mutable this) throws -> Token? {
        if .index > .input.size() {
            return None
        } else if .index == .input.size() {
            ++.index
            return Token::Eof(JaktSpan(start: .index - 1, end: .index - 1))
        }

        while .index < .input.size() and .input[.index] == b' ' {
            ++.index
        }

        let start = .index

        return match .input[.index] {
            (b'(') => Token::LParen(JaktSpan(start, end: ++.index))
            (b')') => Token::RParen(JaktSpan(start, end: ++.index))
            (b'[') => Token::LSquare(JaktSpan(start, end: ++.index))
            (b']') => Token::RSquare(JaktSpan(start, end: ++.index))
            (b'{') => Token::LCurly(JaktSpan(start, end: ++.index))
            (b'}') => Token::RCurly(JaktSpan(start, end: ++.index))
            (b'<') => this.lex_less_than()
            (b'>') => this.lex_greater_than()
            (b'.') => this.lex_dot()
            (b',') => Token::Comma(JaktSpan(start, end: ++.index))
            (b'~') => Token::Tilde(JaktSpan(start, end: ++.index))
            (b';') => Token::Semicolon(JaktSpan(start, end: ++.index))
            (b':') => this.lex_colon()
            (b'?') => this.lex_question_mark()
            (b'+') => this.lex_plus()
            (b'-') => this.lex_minus()
            (b'*') => this.lex_asterisk()
            (b'/') => this.lex_forward_slash()
            (b'^') => this.lex_caret()
            (b'|') => this.lex_pipe()
            (b'%') => this.lex_percent_sign()
            (b'!') => this.lex_exclamation_point()
            (b'&') => this.lex_ampersand()
            (b'$') => Token::Dollar(JaktSpan(start, end: ++.index))
            (b'=') => this.lex_equals()
            (b'\n') => Token::Eol(JaktSpan(start, end: ++.index))
            (b'\'') => this.lex_quoted_string(delimiter: b'\'')                
            (b'\"') => this.lex_quoted_string(delimiter: b'"')
            else => this.lex_number_or_name()
        }
    }
}

function print_error(file_name: String, file_contents: [u8], error: JaktError) throws {
    match error {
        JaktError::Message(msg: message, span: span) => {
            display_message_with_span(severity: MessageSeverity::Error(), file_name, file_contents, message, span)
        }
        JaktError::MessageWithHint(msg: message, span: span, hint: hint, hint_span: hint_span) => {
            display_message_with_span(severity: MessageSeverity::Error(), file_name, file_contents, message, span)
            display_message_with_span(severity: MessageSeverity::Hint(), file_name, file_contents, message: hint, span: hint_span)
        }
    }
}

enum MessageSeverity {
    Hint
    Error
}

function severity_name(severity: MessageSeverity) throws -> String {
    return match severity {
        MessageSeverity::Hint => "Hint"
        MessageSeverity::Error => "Error"
    }
}

function ansi_color_code(severity: MessageSeverity) throws -> String {
    return match severity {
        MessageSeverity::Hint => "94"  // Bright Blue
        MessageSeverity::Error => "31" // Red
    }
}

function display_message_with_span(severity: MessageSeverity, file_name: String, file_contents: [u8], message: String, span: JaktSpan) throws {
    println("{}: {}", severity_name(severity), message)

    let line_spans = gather_line_spans(file_contents)

    let mutable line_index = 1uz
    let largest_line_number = line_spans.size()

    let width = format("{}", largest_line_number).length()

    while line_index < line_spans.size() {
        if span.start >= line_spans[line_index].0 and span.start <= line_spans[line_index].1 {
            let column_index = span.start - line_spans[line_index].0

            println("----- \u001b[33m{}:{}:{}\u001b[0m", file_name, line_index + 1, column_index + 1)

            if line_index > 0 {
                print_source_line(severity, file_contents, line_spans[line_index - 1], span, line_index, largest_line_number)
            }

            print_source_line(severity, file_contents, line_spans[line_index], span, line_index + 1, largest_line_number)

            for x in 0..(span.start - line_spans[line_index].0 + width + 4) {
                print(" ")
            }

            println("\u001b[{}m^- {}\u001b[0m", ansi_color_code(severity), message)

            while line_index < line_spans.size() and span.end > line_spans[line_index].0 {
                ++line_index
                if line_index >= line_spans.size() {
                    break
                }

                print_source_line(severity, file_contents, line_spans[line_index], span, line_index + 1, largest_line_number)

                break
            }
        } else {
            ++line_index
        }

    }
    println("\u001b[0m-----")
}

function print_source_line(anonymous severity: MessageSeverity, anonymous file_contents: [u8], anonymous file_span: (usize, usize), anonymous error_span: JaktSpan, anonymous line_number: usize, anonymous largest_line_number: usize) throws {
    let mutable index = file_span.0

    let width = format("{}", largest_line_number).length()

    print(" {} | ", line_number)

    while index <= file_span.1 {
        let mutable c = b' '
        if index < file_span.1 {
            c = file_contents[index]
        } else if error_span.start == error_span.end and index == error_span.start {
            c = b'_'
        }

        if (index >= error_span.start and index < error_span.end) or (error_span.start == error_span.end and index == error_span.start) {
            print("\u001b[{}m{:c}", ansi_color_code(severity), c)
        } else {
            print("\u001b[0m{:c}", c)
        }

        ++index
    }
    println("")
}

function gather_line_spans(anonymous contents: [u8]) throws -> [(usize, usize)] {
    let mutable idx = 0uz;
    let mutable output: [(usize, usize)] = [];

    let mutable start = idx;
    while idx < contents.size() {
        if contents[idx] == b'\n' {
            output.push((start, idx));
            start = idx + 1;
        }
        idx += 1;
    }
    if start < idx {
        output.push((start, idx));
    }

    return output
}

function main(args: [String]) {
    if args.size() <= 1 {
        eprintln("usage: jakt <path>")
        return 1
    }

    let mutable file = File::open_for_reading(args[1])
    let file_contents = file.read_all()

    let mutable lexer = Lexer(index: 0, input: file_contents, errors: [])
    
    for token in lexer {
        println("token: {}", token)
    }

    for error in lexer.errors.iterator() {
        print_error(file_name: args[1], file_contents, error)
    }
}
